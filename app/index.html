<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lifeline Mesh - Emergency Messaging</title>

  <!-- CDN dependencies (TODO: Add SRI for production) -->
  <script src="https://unpkg.com/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://unpkg.com/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; max-width: 900px; }
    textarea, input, select { width: 100%; padding: 8px; box-sizing: border-box; }
    textarea { min-height: 110px; font-family: monospace; }
    pre { background: #f6f6f6; padding: 10px; border-radius: 8px; white-space: pre-wrap; word-break: break-word; font-size: 12px; }
    button { padding: 10px 12px; cursor: pointer; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1 1 auto; }
    .small { font-size: 12px; opacity: 0.8; }
    .ok { color: #0a7; font-weight: 700; }
    .ng { color: #c33; font-weight: 700; }
    .danger { background: #ffecec; border: 1px solid #ffb3b3; }
    .section { margin-bottom: 24px; }
    details { margin: 8px 0; }
    summary { cursor: pointer; font-weight: 600; padding: 8px; background: #f0f0f0; border-radius: 4px; }
  </style>
</head>

<body>
  <h1>ğŸŒ Lifeline Mesh</h1>
  <p class="small">
    End-to-end encrypted emergency messaging â€¢ Offline-first â€¢ No server required<br>
    âœ… Ed25519 signatures â€¢ âœ… X25519 encryption â€¢ âœ… Ephemeral keys â€¢ âœ… Replay protection â€¢ âœ… TOFU
  </p>

  <div class="section">
    <h2>1) Your Keys</h2>
    <div class="row">
      <button onclick="initOrLoad()">ğŸ”‘ Generate / Load Keys</button>
      <button class="danger" onclick="resetAll()">ğŸ—‘ï¸ RESET ALL</button>
    </div>
    <pre id="my-id">(not loaded)</pre>
    <div class="row">
      <button onclick="copyMyId()">ğŸ“‹ Copy My Public ID</button>
      <button onclick="exportKeys()">ğŸ’¾ Export Keys</button>
      <button onclick="importKeys()">ğŸ“¥ Import Keys</button>
    </div>

    <details>
      <summary>Key Management</summary>
      <p class="small">
        <strong>Export:</strong> Download your secret keys as encrypted JSON (password-protected)<br>
        <strong>Import:</strong> Restore keys from backup file<br>
        <strong>âš ï¸ Warning:</strong> Keep exported keys secure. Anyone with your secret keys can impersonate you.
      </p>
    </details>
  </div>

  <div class="section">
    <h2>2) Contacts</h2>
    <textarea id="contact-input" placeholder='{"name":"Bob","signPK":"base64","boxPK":"base64"}'></textarea>
    <div class="row">
      <button onclick="addContact()">â• Add Contact</button>
      <button onclick="refreshContacts()">ğŸ”„ Refresh</button>
      <button class="danger" onclick="deleteSelectedContact()">âŒ Delete Selected</button>
    </div>
    <select id="recipient-select">
      <option value="">Select Recipient</option>
    </select>
    <pre id="contacts-view">(none)</pre>
  </div>

  <div class="section">
    <h2>3) Encrypt Message</h2>
    <textarea id="content" placeholder="Type your message here (max 150KB)"></textarea>
    <div class="row">
      <button onclick="encryptMsg()">ğŸ”’ Encrypt</button>
      <span class="small">Recipient: <strong id="encrypt-recipient">(select above)</strong></span>
    </div>
    <pre id="encrypted"></pre>
    <div class="row" id="encrypted-actions" style="display:none">
      <button onclick="copyEncrypted()">ğŸ“‹ Copy Encrypted Message</button>
    </div>
  </div>

  <div class="section">
    <h2>4) Decrypt Message</h2>
    <textarea id="input" placeholder="Paste encrypted JSON message here"></textarea>
    <label class="small">
      <input type="checkbox" id="tofu" />
      TOFU (Trust On First Use - auto-accept unknown senders)
    </label>
    <div class="row">
      <button onclick="decryptMsg()">ğŸ”“ Decrypt</button>
    </div>
    <pre id="status"></pre>
    <pre id="decrypted"></pre>
  </div>

  <div class="section">
    <details>
      <summary>ğŸ“š Documentation</summary>
      <ul>
        <li><a href="../docs/USAGE.md" target="_blank">Usage Guide</a></li>
        <li><a href="../docs/FAQ.md" target="_blank">FAQ</a></li>
        <li><a href="../spec/THREAT_MODEL.md" target="_blank">Threat Model</a></li>
        <li><a href="../spec/PROTOCOL.md" target="_blank">Protocol Specification</a></li>
      </ul>
    </details>
  </div>

<script type="module">
/* =========================
  Import crypto core
========================= */
import * as DMesh from '../crypto/core.js';

/* =========================
  Config
========================= */
const DB_NAME = "lifelineMesh";
const DB_VERSION = 1;
const STORE_KEYS = "keys";
const STORE_CONTACTS = "contacts";
const STORE_REPLAY = "replay";

/* =========================
  IndexedDB helpers
========================= */
let dbPromise = null;

function openDB() {
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_KEYS)) db.createObjectStore(STORE_KEYS);
      if (!db.objectStoreNames.contains(STORE_CONTACTS)) db.createObjectStore(STORE_CONTACTS, { keyPath: "fp" });
      if (!db.objectStoreNames.contains(STORE_REPLAY)) db.createObjectStore(STORE_REPLAY, { keyPath: "k" });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return dbPromise;
}

async function idbGet(store, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readonly");
    const req = tx.objectStore(store).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbPut(store, value, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readwrite");
    const st = tx.objectStore(store);
    if (key !== undefined) st.put(value, key);
    else st.put(value);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function idbDel(store, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readwrite");
    tx.objectStore(store).delete(key);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function idbGetAll(store) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readonly");
    const req = tx.objectStore(store).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

/* =========================
  Utility
========================= */
function setStatus(ok, msg) {
  document.getElementById("status").innerHTML = (ok ? `<span class="ok">âœ“ OK</span> ` : `<span class="ng">âœ— ERROR</span> `) + msg;
}

/* =========================
  Key Management
========================= */
async function ensureMyKeys() {
  let signPK = await idbGet(STORE_KEYS, "my_sign_pk");
  let signSK = await idbGet(STORE_KEYS, "my_sign_sk");
  let boxPK = await idbGet(STORE_KEYS, "my_box_pk");
  let boxSK = await idbGet(STORE_KEYS, "my_box_sk");

  if (!signPK || !signSK) {
    const kp = DMesh.generateSignKeyPair(nacl);
    signPK = nacl.util.encodeBase64(kp.publicKey);
    signSK = nacl.util.encodeBase64(kp.secretKey);
    await idbPut(STORE_KEYS, signPK, "my_sign_pk");
    await idbPut(STORE_KEYS, signSK, "my_sign_sk");
  }

  if (!boxPK || !boxSK) {
    const kp = DMesh.generateBoxKeyPair(nacl);
    boxPK = nacl.util.encodeBase64(kp.publicKey);
    boxSK = nacl.util.encodeBase64(kp.secretKey);
    await idbPut(STORE_KEYS, boxPK, "my_box_pk");
    await idbPut(STORE_KEYS, boxSK, "my_box_sk");
  }

  return {
    signPKu8: nacl.util.decodeBase64(signPK),
    signSKu8: nacl.util.decodeBase64(signSK),
    boxPKu8: nacl.util.decodeBase64(boxPK),
    boxSKu8: nacl.util.decodeBase64(boxSK)
  };
}

window.initOrLoad = async function() {
  try {
    const my = await ensureMyKeys();
    const myId = DMesh.createPublicIdentity({
      name: "(optional)",
      signPK: my.signPKu8,
      boxPK: my.boxPKu8
    }, nacl, nacl.util);

    document.getElementById("my-id").textContent = JSON.stringify(myId, null, 2);
    await refreshContacts();
    setStatus(true, `Keys ready. Fingerprint: ${myId.fp}`);
  } catch (e) {
    setStatus(false, e.message);
  }
};

window.copyMyId = async function() {
  const t = document.getElementById("my-id").textContent;
  if (!t || t === "(not loaded)") return alert("Generate keys first");
  await navigator.clipboard.writeText(t);
  setStatus(true, "Public ID copied to clipboard");
};

window.exportKeys = async function() {
  const password = prompt("Enter password to encrypt your keys:");
  if (!password) return;

  try {
    const signPK = await idbGet(STORE_KEYS, "my_sign_pk");
    const signSK = await idbGet(STORE_KEYS, "my_sign_sk");
    const boxPK = await idbGet(STORE_KEYS, "my_box_pk");
    const boxSK = await idbGet(STORE_KEYS, "my_box_sk");

    if (!signPK || !signSK || !boxPK || !boxSK) {
      return alert("No keys to export. Generate keys first.");
    }

    // Simple password-based encryption (XOR with password hash)
    // WARNING: This is NOT cryptographically secure - for demo only!
    const passwordHash = nacl.hash(nacl.util.decodeUTF8(password));

    const encrypt = (data) => {
      const dataBytes = nacl.util.decodeBase64(data);
      const encrypted = new Uint8Array(dataBytes.length);
      for (let i = 0; i < dataBytes.length; i++) {
        encrypted[i] = dataBytes[i] ^ passwordHash[i % passwordHash.length];
      }
      return nacl.util.encodeBase64(encrypted);
    };

    const backup = {
      version: 1,
      exported: new Date().toISOString(),
      keys: {
        signPK: encrypt(signPK),
        signSK: encrypt(signSK),
        boxPK: encrypt(boxPK),
        boxSK: encrypt(boxSK)
      }
    };

    const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `lifeline-mesh-keys-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);

    setStatus(true, "Keys exported successfully");
  } catch (e) {
    setStatus(false, "Export failed: " + e.message);
  }
};

window.importKeys = async function() {
  const password = prompt("Enter password to decrypt your keys:");
  if (!password) return;

  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';

  input.onchange = async (e) => {
    try {
      const file = e.target.files[0];
      const text = await file.text();
      const backup = JSON.parse(text);

      if (backup.version !== 1 || !backup.keys) {
        return alert("Invalid backup file format");
      }

      // Decrypt
      const passwordHash = nacl.hash(nacl.util.decodeUTF8(password));

      const decrypt = (encrypted) => {
        const encryptedBytes = nacl.util.decodeBase64(encrypted);
        const decrypted = new Uint8Array(encryptedBytes.length);
        for (let i = 0; i < encryptedBytes.length; i++) {
          decrypted[i] = encryptedBytes[i] ^ passwordHash[i % passwordHash.length];
        }
        return nacl.util.encodeBase64(decrypted);
      };

      const signPK = decrypt(backup.keys.signPK);
      const signSK = decrypt(backup.keys.signSK);
      const boxPK = decrypt(backup.keys.boxPK);
      const boxSK = decrypt(backup.keys.boxSK);

      // Verify key lengths
      if (nacl.util.decodeBase64(signPK).length !== 32 ||
          nacl.util.decodeBase64(signSK).length !== 64 ||
          nacl.util.decodeBase64(boxPK).length !== 32 ||
          nacl.util.decodeBase64(boxSK).length !== 32) {
        return alert("Decryption failed - wrong password or corrupted file");
      }

      // Save to IndexedDB
      await idbPut(STORE_KEYS, signPK, "my_sign_pk");
      await idbPut(STORE_KEYS, signSK, "my_sign_sk");
      await idbPut(STORE_KEYS, boxPK, "my_box_pk");
      await idbPut(STORE_KEYS, boxSK, "my_box_sk");

      await initOrLoad();
      setStatus(true, "Keys imported successfully");
    } catch (e) {
      setStatus(false, "Import failed: " + e.message);
    }
  };

  input.click();
};

window.resetAll = async function() {
  if (!confirm("âš ï¸ Delete ALL data (keys, contacts, replay DB)?\nThis cannot be undone!")) return;

  if (dbPromise) {
    const db = await dbPromise;
    db.close();
    dbPromise = null;
  }

  await new Promise((resolve, reject) => {
    const req = indexedDB.deleteDatabase(DB_NAME);
    req.onsuccess = resolve;
    req.onerror = () => reject(req.error);
  });

  document.getElementById("my-id").textContent = "(not loaded)";
  document.getElementById("contacts-view").textContent = "(none)";
  document.getElementById("recipient-select").innerHTML = `<option value="">Select Recipient</option>`;
  document.getElementById("encrypted").textContent = "";
  document.getElementById("decrypted").textContent = "";
  setStatus(true, "All data deleted");
};

/* =========================
  Contacts
========================= */
window.addContact = async function() {
  try {
    const obj = JSON.parse(document.getElementById("contact-input").value.trim());

    if (!obj || !obj.signPK || !obj.boxPK) {
      return alert("Invalid format. Need: signPK and boxPK");
    }

    const signPKu8 = nacl.util.decodeBase64(obj.signPK);
    const boxPKu8 = nacl.util.decodeBase64(obj.boxPK);

    if (signPKu8.length !== 32) return alert("Invalid signPK length");
    if (boxPKu8.length !== 32) return alert("Invalid boxPK length");

    const fp = DMesh.fingerprintFromSignPK(signPKu8, nacl);
    const fpB64 = nacl.util.encodeBase64(fp);

    const contact = {
      fp: fpB64,
      name: obj.name || `Contact-${fpB64.slice(0, 8)}`,
      signPK: obj.signPK,
      boxPK: obj.boxPK,
      addedAt: Date.now()
    };

    await idbPut(STORE_CONTACTS, contact);
    await refreshContacts();
    setStatus(true, `Contact saved: ${contact.name} (fp: ${fpB64.slice(0, 16)}...)`);
  } catch (e) {
    setStatus(false, "Add contact failed: " + e.message);
  }
};

window.refreshContacts = async function() {
  const contacts = await idbGetAll(STORE_CONTACTS);
  contacts.sort((a, b) => (a.name || "").localeCompare(b.name || ""));

  const sel = document.getElementById("recipient-select");
  sel.innerHTML = `<option value="">Select Recipient</option>`;

  for (const c of contacts) {
    const opt = document.createElement("option");
    opt.value = c.fp;
    opt.textContent = `${c.name} [${c.fp.slice(0, 12)}...]`;
    sel.appendChild(opt);
  }

  sel.onchange = () => {
    const selected = sel.options[sel.selectedIndex].text;
    document.getElementById("encrypt-recipient").textContent = selected || "(select above)";
  };

  document.getElementById("contacts-view").textContent =
    contacts.length ? JSON.stringify(contacts, null, 2) : "(none)";
};

window.deleteSelectedContact = async function() {
  const fp = document.getElementById("recipient-select").value;
  if (!fp) return alert("Select a contact first");

  await idbDel(STORE_CONTACTS, fp);
  await refreshContacts();
  setStatus(true, `Contact deleted (fp: ${fp.slice(0, 16)}...)`);
};

/* =========================
  Encryption
========================= */
window.encryptMsg = async function() {
  try {
    const content = document.getElementById("content").value || "";
    const fp = document.getElementById("recipient-select").value;

    if (!fp) return alert("Select a recipient");

    const recipient = await idbGet(STORE_CONTACTS, fp);
    if (!recipient) return alert("Recipient not found");

    const my = await ensureMyKeys();

    const message = DMesh.encryptMessage({
      content,
      senderSignPK: my.signPKu8,
      senderSignSK: my.signSKu8,
      senderBoxPK: my.boxPKu8,
      senderBoxSK: my.boxSKu8,
      recipientBoxPK: nacl.util.decodeBase64(recipient.boxPK)
    }, nacl, nacl.util);

    document.getElementById("encrypted").textContent = JSON.stringify(message, null, 2);
    document.getElementById("encrypted-actions").style.display = "flex";
    setStatus(true, `Encrypted for ${recipient.name}`);
  } catch (e) {
    setStatus(false, "Encryption failed: " + e.message);
  }
};

window.copyEncrypted = async function() {
  const text = document.getElementById("encrypted").textContent;
  await navigator.clipboard.writeText(text);
  setStatus(true, "Encrypted message copied to clipboard");
};

/* =========================
  Decryption
========================= */
async function cleanupReplay() {
  const all = await idbGetAll(STORE_REPLAY);
  const now = Date.now();
  const old = all.filter(x => (now - (x.seenAt || 0)) > DMesh.REPLAY_RETENTION_MS);
  for (const o of old) await idbDel(STORE_REPLAY, o.k);
}

async function checkAndMarkReplay(senderFp, nonceB64) {
  await cleanupReplay();
  const k = `${senderFp}:${nonceB64}`;
  const existing = await idbGet(STORE_REPLAY, k);
  if (existing) return false;
  await idbPut(STORE_REPLAY, { k, seenAt: Date.now() });
  return true;
}

window.decryptMsg = async function() {
  try {
    const message = JSON.parse(document.getElementById("input").value.trim());
    const my = await ensureMyKeys();

    // Sender fingerprint
    const senderSignPK = nacl.util.decodeBase64(message.senderSignPK);
    const senderFp = DMesh.fingerprintFromSignPK(senderSignPK, nacl);
    const senderFpB64 = nacl.util.encodeBase64(senderFp);

    // Contact lookup
    let contact = await idbGet(STORE_CONTACTS, senderFpB64);

    let expectedSenderSignPK = null;
    let expectedSenderBoxPK = null;

    if (!contact) {
      if (!document.getElementById("tofu").checked) {
        setStatus(false, `Unknown sender (fp: ${senderFpB64.slice(0, 16)}...). Enable TOFU or add contact first.`);
        return;
      }
      // TOFU registration
      contact = {
        fp: senderFpB64,
        name: `TOFU-${senderFpB64.slice(0, 8)}`,
        signPK: message.senderSignPK,
        boxPK: message.senderBoxPK,
        addedAt: Date.now()
      };
      await idbPut(STORE_CONTACTS, contact);
      await refreshContacts();
    } else {
      // Known sender - expect keys to match
      expectedSenderSignPK = nacl.util.decodeBase64(contact.signPK);
      expectedSenderBoxPK = nacl.util.decodeBase64(contact.boxPK);
    }

    // Replay check function
    const replayCheck = (fp, nonceB64) => checkAndMarkReplay(fp, nonceB64);

    // Decrypt
    const result = DMesh.decryptMessage({
      message,
      recipientBoxPK: my.boxPKu8,
      recipientBoxSK: my.boxSKu8,
      expectedSenderSignPK,
      expectedSenderBoxPK,
      replayCheck
    }, nacl, nacl.util);

    document.getElementById("decrypted").textContent = result.content;
    setStatus(true, `âœ“ Decrypted from ${contact.name} (fp: ${senderFpB64.slice(0, 16)}...)`);
  } catch (e) {
    setStatus(false, "Decryption failed: " + e.message);
    document.getElementById("decrypted").textContent = "";
  }
};

/* =========================
  Auto-init
========================= */
(async () => {
  try {
    await initOrLoad();
  } catch (e) {
    console.error("Auto-init failed:", e);
  }
})();
</script>
</body>
</html>
