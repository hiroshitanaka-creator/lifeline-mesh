<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Disaster Mesh Crypto - Complete</title>

  <!-- 動作優先。SRIは末尾に付け方を書く（間違うと100%動かない） -->
  <script src="https://unpkg.com/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://unpkg.com/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    textarea, input, select { width: 100%; padding: 8px; box-sizing: border-box; }
    textarea { min-height: 110px; }
    pre { background: #f6f6f6; padding: 10px; border-radius: 8px; white-space: pre-wrap; word-break: break-word; }
    button { padding: 10px 12px; cursor: pointer; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1 1 auto; }
    .small { font-size: 12px; opacity: 0.8; }
    .ok { color: #0a7; font-weight: 700; }
    .ng { color: #c33; font-weight: 700; }
    .danger { background: #ffecec; border: 1px solid #ffb3b3; }
  </style>
</head>

<body>
  <h1>Disaster Mesh Crypto - Complete</h1>
  <div class="small">
    ✅ sign(Ed25519) と box(X25519-XSalsa20-Poly1305) 鍵分離 / ✅ ephemeral box鍵 / ✅ 受信者束縛 / ✅ TOFU成立 / ✅ リプレイ防止 / ✅ 署名データ完全一致
  </div>

  <h2>1) 自分の鍵 (IndexedDB)</h2>
  <div class="row">
    <button onclick="initOrLoad()">Generate / Load Keys</button>
    <button class="danger" onclick="resetAll()">RESET ALL (keys/contacts/replay)</button>
  </div>
  <pre id="my-id">(not loaded)</pre>
  <div class="row">
    <button onclick="copyMyId()">Copy My Public ID</button>
  </div>

  <h2>2) 連絡先登録 (SignPK + BoxPK)</h2>
  <textarea id="contact-input" placeholder='{"name":"Bob","signPK":"base64","boxPK":"base64"}'></textarea>
  <div class="row">
    <button onclick="addContact()">Add / Update Contact</button>
    <button onclick="refreshContacts()">Refresh</button>
    <button class="danger" onclick="deleteSelectedContact()">Delete Selected</button>
  </div>
  <select id="recipient-select">
    <option value="">Select Recipient</option>
  </select>
  <pre id="contacts-view">(none)</pre>

  <h2>3) Encrypt</h2>
  <textarea id="content" placeholder="Content (max 150KB)"></textarea>
  <div class="row">
    <button onclick="encryptMsg()">Encrypt</button>
    <span class="small">送信先は上のSelectで選択</span>
  </div>
  <pre id="encrypted"></pre>

  <h2>4) Decrypt</h2>
  <textarea id="input" placeholder="Paste encrypted JSON"></textarea>
  <label class="small"><input type="checkbox" id="tofu" /> TOFU（未登録送信者を初回だけ自動登録：初回なりすましは防げない）</label>
  <div class="row">
    <button onclick="decryptMsg()">Decrypt</button>
  </div>
  <pre id="status"></pre>
  <pre id="decrypted"></pre>

<script>
/* =========================
  Config
========================= */
const DB_NAME = "disasterMeshComplete";
const DB_VERSION = 1;
const STORE_KEYS = "keys";
const STORE_CONTACTS = "contacts"; // keyPath: fp
const STORE_REPLAY = "replay";     // keyPath: k

const MAX_BYTES = 150 * 1024;
const MAX_SKEW_MS = 10 * 60 * 1000;        // 10分
const REPLAY_RETENTION_MS = 30 * 24 * 60 * 60 * 1000; // 30日

// 署名ドメイン分離（他用途で同じ署名を流用されない）
const DOMAIN = nacl.util.decodeUTF8("DMESH_MSG_V1");

/* =========================
  IndexedDB helpers (標準APIで確実に待つ)
========================= */
let dbPromise = null;

function openDB() {
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_KEYS)) db.createObjectStore(STORE_KEYS);
      if (!db.objectStoreNames.contains(STORE_CONTACTS)) db.createObjectStore(STORE_CONTACTS, { keyPath: "fp" });
      if (!db.objectStoreNames.contains(STORE_REPLAY)) db.createObjectStore(STORE_REPLAY, { keyPath: "k" });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return dbPromise;
}

async function idbGet(store, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readonly");
    const st = tx.objectStore(store);
    const req = st.get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbPut(store, value, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readwrite");
    const st = tx.objectStore(store);
    if (key !== undefined) st.put(value, key);
    else st.put(value);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
    tx.onabort = () => reject(tx.error);
  });
}

async function idbDel(store, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readwrite");
    tx.objectStore(store).delete(key);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
    tx.onabort = () => reject(tx.error);
  });
}

async function idbGetAll(store) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readonly");
    const req = tx.objectStore(store).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

/* =========================
  Bytes utilities
========================= */
const b64e = (u8) => nacl.util.encodeBase64(u8);
const b64d = (s) => nacl.util.decodeBase64(s);

function concatU8(arrs) {
  const total = arrs.reduce((n, a) => n + a.length, 0);
  const out = new Uint8Array(total);
  let off = 0;
  for (const a of arrs) { out.set(a, off); off += a.length; }
  return out;
}

function u32be(n) {
  const b = new Uint8Array(4);
  const dv = new DataView(b.buffer);
  dv.setUint32(0, n >>> 0, false); // big-endian
  return b;
}

function u64beFromNumber(ts) {
  // JS numberは53bit精度。Date.now()は安全域。
  const hi = Math.floor(ts / 4294967296);
  const lo = ts >>> 0;
  const b = new Uint8Array(8);
  const dv = new DataView(b.buffer);
  dv.setUint32(0, hi >>> 0, false);
  dv.setUint32(4, lo >>> 0, false);
  return b;
}

function setStatus(ok, msg) {
  document.getElementById("status").innerHTML = (ok ? `<span class="ok">OK</span> ` : `<span class="ng">NG</span> `) + msg;
}

/* =========================
  Fingerprint (signPK由来で統一)
  - TweetNaCl hash = SHA-512
========================= */
function fingerprintFromSignPK(signPKu8) {
  const h = nacl.hash(signPKu8); // 64 bytes
  return b64e(h.slice(0, 16));   // 16 bytes -> 短すぎない指紋
}

/* =========================
  Keys (base64保存)
========================= */
async function ensureMyKeys() {
  let signPK = await idbGet(STORE_KEYS, "my_sign_pk");
  let signSK = await idbGet(STORE_KEYS, "my_sign_sk");
  let boxPK  = await idbGet(STORE_KEYS, "my_box_pk");
  let boxSK  = await idbGet(STORE_KEYS, "my_box_sk");

  if (!signPK || !signSK) {
    const kp = nacl.sign.keyPair();
    signPK = b64e(kp.publicKey);
    signSK = b64e(kp.secretKey);
    await idbPut(STORE_KEYS, signPK, "my_sign_pk");
    await idbPut(STORE_KEYS, signSK, "my_sign_sk");
  }

  if (!boxPK || !boxSK) {
    const kp = nacl.box.keyPair();
    boxPK = b64e(kp.publicKey);
    boxSK = b64e(kp.secretKey);
    await idbPut(STORE_KEYS, boxPK, "my_box_pk");
    await idbPut(STORE_KEYS, boxSK, "my_box_sk");
  }

  const signPKu8 = b64d(signPK);
  const signSKu8 = b64d(signSK);
  const boxPKu8  = b64d(boxPK);
  const boxSKu8  = b64d(boxSK);

  return { signPKu8, signSKu8, boxPKu8, boxSKu8 };
}

async function initOrLoad() {
  const my = await ensureMyKeys();
  const fp = fingerprintFromSignPK(my.signPKu8);

  const myId = {
    v: 1,
    kind: "dmesh-id",
    name: "(optional)",
    fp,
    signPK: b64e(my.signPKu8),
    boxPK: b64e(my.boxPKu8)
  };

  document.getElementById("my-id").textContent = JSON.stringify(myId, null, 2);
  await refreshContacts();
  setStatus(true, `Keys ready. My fp=${fp}`);
}

async function copyMyId() {
  const t = document.getElementById("my-id").textContent;
  if (!t || t === "(not loaded)") return alert("まずGenerate/Load Keys");
  await navigator.clipboard.writeText(t);
  setStatus(true, "Copied My Public ID");
}

async function resetAll() {
  if (!confirm("本当に全データ削除？（鍵も消える）")) return;
  if (dbPromise) {
    const db = await dbPromise;
    db.close();
    dbPromise = null;
  }
  await new Promise((resolve, reject) => {
    const req = indexedDB.deleteDatabase(DB_NAME);
    req.onsuccess = resolve;
    req.onerror = () => reject(req.error);
  });
  document.getElementById("my-id").textContent = "(not loaded)";
  document.getElementById("contacts-view").textContent = "(none)";
  document.getElementById("recipient-select").innerHTML = `<option value="">Select Recipient</option>`;
  document.getElementById("encrypted").textContent = "";
  document.getElementById("decrypted").textContent = "";
  setStatus(true, "RESET done");
}

/* =========================
  Contacts
========================= */
async function addContact() {
  let obj;
  try { obj = JSON.parse(document.getElementById("contact-input").value.trim()); }
  catch { return alert("Invalid JSON"); }

  if (!obj || !obj.signPK || !obj.boxPK) return alert("Need signPK + boxPK");

  let signPKu8, boxPKu8;
  try {
    signPKu8 = b64d(obj.signPK);
    boxPKu8  = b64d(obj.boxPK);
  } catch {
    return alert("Base64 decode failed");
  }

  if (signPKu8.length !== nacl.sign.publicKeyLength) return alert("signPK length invalid");
  if (boxPKu8.length !== nacl.box.publicKeyLength) return alert("boxPK length invalid");

  const fp = fingerprintFromSignPK(signPKu8);

  const contact = {
    fp,
    name: (obj.name || `Contact-${fp}`),
    signPK: obj.signPK,
    boxPK: obj.boxPK,
    addedAt: Date.now()
  };

  await idbPut(STORE_CONTACTS, contact);
  await refreshContacts();
  setStatus(true, `Contact saved: ${contact.name} fp=${fp}`);
}

async function refreshContacts() {
  const contacts = await idbGetAll(STORE_CONTACTS);
  contacts.sort((a,b) => (a.name||"").localeCompare(b.name||""));

  const sel = document.getElementById("recipient-select");
  sel.innerHTML = `<option value="">Select Recipient</option>`;
  for (const c of contacts) {
    const opt = document.createElement("option");
    opt.value = c.fp; // fpをvalueにする（boxPKだけにしない！）
    opt.textContent = `${c.name} [fp:${c.fp}]`;
    sel.appendChild(opt);
  }

  document.getElementById("contacts-view").textContent =
    contacts.length ? JSON.stringify(contacts, null, 2) : "(none)";
}

async function deleteSelectedContact() {
  const fp = document.getElementById("recipient-select").value;
  if (!fp) return alert("Select contact");
  await idbDel(STORE_CONTACTS, fp);
  await refreshContacts();
  setStatus(true, `Deleted contact fp=${fp}`);
}

/* =========================
  Message signing (encrypt/decryptで完全一致させる)
  SignBytes = concat([
    DOMAIN,
    senderSignPK(32),
    senderBoxPK(32),
    recipientBoxPK(32),
    ephPK(32),
    nonce(24),
    ts_u64be(8),
    ct_len_u32be(4),
    ciphertext
  ])
========================= */
function buildSignBytes({ senderSignPK, senderBoxPK, recipientBoxPK, ephPK, nonce, ts, ciphertext }) {
  return concatU8([
    DOMAIN,
    senderSignPK,
    senderBoxPK,
    recipientBoxPK,
    ephPK,
    nonce,
    u64beFromNumber(ts),
    u32be(ciphertext.length),
    ciphertext
  ]);
}

/* =========================
  Replay protection
========================= */
async function cleanupReplay() {
  const all = await idbGetAll(STORE_REPLAY);
  const now = Date.now();
  const old = all.filter(x => (now - (x.seenAt || 0)) > REPLAY_RETENTION_MS);
  for (const o of old) await idbDel(STORE_REPLAY, o.k);
}

async function checkAndMarkReplay(senderFp, nonceB64) {
  await cleanupReplay();
  const k = `${senderFp}:${nonceB64}`;
  const existing = await idbGet(STORE_REPLAY, k);
  if (existing) return false;
  await idbPut(STORE_REPLAY, { k, seenAt: Date.now() });
  return true;
}

/* =========================
  Encrypt
========================= */
async function encryptMsg() {
  const content = document.getElementById("content").value || "";
  if (new Blob([content]).size > MAX_BYTES) return alert("Too large (max 150KB)");

  const fp = document.getElementById("recipient-select").value;
  if (!fp) return alert("Select recipient");

  const recipient = await idbGet(STORE_CONTACTS, fp);
  if (!recipient) return alert("Recipient not found");

  const my = await ensureMyKeys();
  const recipientBoxPK = b64d(recipient.boxPK);

  // ephemeral box keys (PFS近似)
  const eph = nacl.box.keyPair();
  const nonce = nacl.randomBytes(nacl.box.nonceLength);

  const ts = Date.now();
  const payloadBytes = nacl.util.decodeUTF8(JSON.stringify({ v: 1, ts, content }));

  // ECDH shared + box.after
  const shared = nacl.box.before(recipientBoxPK, eph.secretKey);
  const ciphertext = nacl.box.after(payloadBytes, nonce, shared);
  if (!ciphertext) return alert("Encrypt failed (unexpected)");

  const signBytes = buildSignBytes({
    senderSignPK: my.signPKu8,
    senderBoxPK: my.boxPKu8,
    recipientBoxPK,
    ephPK: eph.publicKey,
    nonce,
    ts,
    ciphertext
  });

  const signature = nacl.sign.detached(signBytes, my.signSKu8);

  const msg = {
    v: 1,
    kind: "dmesh-msg",
    ts,
    senderSignPK: b64e(my.signPKu8),
    senderBoxPK: b64e(my.boxPKu8),
    recipientBoxPK: b64e(recipientBoxPK),
    ephPK: b64e(eph.publicKey),
    nonce: b64e(nonce),
    ciphertext: b64e(ciphertext),
    signature: b64e(signature)
  };

  document.getElementById("encrypted").textContent = JSON.stringify(msg, null, 2);
  setStatus(true, `Encrypted for ${recipient.name} fp=${recipient.fp}`);
}

/* =========================
  Decrypt
========================= */
async function decryptMsg() {
  let msg;
  try { msg = JSON.parse(document.getElementById("input").value.trim()); }
  catch { return alert("Invalid JSON"); }

  if (!msg || msg.v !== 1 || msg.kind !== "dmesh-msg") return alert("Invalid message format");

  // decode base64 fields
  let senderSignPK, senderBoxPK, recipientBoxPK, ephPK, nonce, ciphertext, signature;
  try {
    senderSignPK = b64d(msg.senderSignPK);
    senderBoxPK  = b64d(msg.senderBoxPK);
    recipientBoxPK = b64d(msg.recipientBoxPK);
    ephPK = b64d(msg.ephPK);
    nonce = b64d(msg.nonce);
    ciphertext = b64d(msg.ciphertext);
    signature = b64d(msg.signature);
  } catch {
    return alert("Base64 decode failed");
  }

  // length checks
  if (senderSignPK.length !== nacl.sign.publicKeyLength) return alert("senderSignPK length invalid");
  if (senderBoxPK.length !== nacl.box.publicKeyLength) return alert("senderBoxPK length invalid");
  if (recipientBoxPK.length !== nacl.box.publicKeyLength) return alert("recipientBoxPK length invalid");
  if (ephPK.length !== nacl.box.publicKeyLength) return alert("ephPK length invalid");
  if (nonce.length !== nacl.box.nonceLength) return alert("nonce length invalid");
  if (signature.length !== nacl.sign.signatureLength) return alert("signature length invalid");

  const ts = Number(msg.ts);
  if (!Number.isFinite(ts)) return alert("ts invalid");

  // timestamp skew
  if (Math.abs(Date.now() - ts) > MAX_SKEW_MS) {
    setStatus(false, "Timestamp skew too large -> drop");
    return;
  }

  const my = await ensureMyKeys();

  // 受信者束縛: 自分宛てか？
  if (b64e(my.boxPKu8) !== msg.recipientBoxPK) {
    setStatus(false, "Not for you (recipientBoxPK mismatch) -> drop");
    return;
  }

  // sender fingerprint
  const senderFp = fingerprintFromSignPK(senderSignPK);

  // contact lookup / TOFU
  let contact = await idbGet(STORE_CONTACTS, senderFp);

  if (!contact) {
    if (!document.getElementById("tofu").checked) {
      setStatus(false, `Unknown sender fp=${senderFp} (TOFU off) -> drop`);
      return;
    }
    // TOFU登録（初回はなりすましに弱いのは仕様）
    contact = {
      fp: senderFp,
      name: `TOFU-${senderFp}`,
      signPK: msg.senderSignPK,
      boxPK: msg.senderBoxPK,
      addedAt: Date.now()
    };
    await idbPut(STORE_CONTACTS, contact);
    await refreshContacts();
  } else {
    // 既知送信者なら鍵固定（すり替え拒否）
    if (contact.signPK !== msg.senderSignPK || contact.boxPK !== msg.senderBoxPK) {
      setStatus(false, `Sender key mismatch for fp=${senderFp} -> drop`);
      return;
    }
  }

  // signature verify (encryptと完全同一のSignBytesを再構成)
  const signBytes = buildSignBytes({
    senderSignPK,
    senderBoxPK,
    recipientBoxPK,
    ephPK,
    nonce,
    ts,
    ciphertext
  });

  const verified = nacl.sign.detached.verify(signBytes, signature, senderSignPK);
  if (!verified) {
    setStatus(false, `Invalid signature fp=${senderFp} -> drop`);
    return;
  }

  // replay check (署名OKの後)
  const okReplay = await checkAndMarkReplay(senderFp, msg.nonce);
  if (!okReplay) {
    setStatus(false, `Replay detected fp=${senderFp} -> drop`);
    return;
  }

  // decrypt
  const shared = nacl.box.before(ephPK, my.boxSKu8);
  const plaintext = nacl.box.open.after(ciphertext, nonce, shared);
  if (!plaintext) {
    setStatus(false, `Decryption failed fp=${senderFp}`);
    return;
  }

  const text = nacl.util.encodeUTF8(plaintext);

  // payload parse (任意)
  try {
    const obj = JSON.parse(text);
    document.getElementById("decrypted").textContent = obj.content ?? JSON.stringify(obj, null, 2);
  } catch {
    document.getElementById("decrypted").textContent = text;
  }

  setStatus(true, `Decrypted OK from ${contact.name} fp=${senderFp}`);
}

/* Auto init (好みで) */
(async () => {
  try { await initOrLoad(); } catch (e) { console.error(e); }
})();
</script>
</body>
</html>
